[toc]

#  对象和类
##  内容：
##  过程性编程和面向对象编程
- 我的理解：
  - 过程性编程
    使用语言提供的基础数据类型、按特定的算法步骤编写程序逻辑、一般对于不同的流程使用不同的函数来达到数据处理的过程。
  - 面向对象编程
    关注于数据本身的表现与行为、创造了新的数据类型。

- 书本：
  - 过程性编程
    遵循特定的步骤处理数据 ———— 整体步骤优先与数据
  - 面向对象编程
    首先考虑数据，然后考虑如何使用这些数据。

- 区别：
  过程性编程和明显，是以过程为导向的思维方式，按什么顺序获取数据，数据按什么流程进行处理。也就是说，你没办法按你想要的方式去对数据进行处理，因为对数据进行处理的流程是固定的。就存在这样一种情况，有些数据，我可能只是需要数据的一部分，可是按流程处理后得到的是全方面处理后的数据。这种方式很适合统一流程处理数据。优点：统一、标准；缺点：不灵活、死板。
  面向对象编程考虑的是数据的抽象以及行为方式。是一种以数据为导向的编程方式。可以通过数据不同的表现方式来处理同一数据或者是不同数据。优点：灵活。

- OOP编程与类的关系
  OOP是一种编程理念，而类是该理念实现的一种方式。

##  类概念
- 我的理解：
  就一个事物而言，是存在多种属性的，我们关注的是其中的某一项属性。此时就需要简化模型与然后提取抽象，然后将抽象的部分视为一个研究的整体，这样就构成了类的概念。所以抽象与类是相辅相成的。类是某部分抽象的集合。

- 类型是什么？
  比如如何区分char与double类型，我们可以从其表示的存储空间的大小出发。这样就有一个问题，内存空间大小一样的一定是同一个概念吗？如在C和C++中，指针类型和int类型的存储空间相同。有时甚至用int型来存储指针。但是它们就是同一个概念了吗？不是，那么我们是怎样来区分它们的呢？对于int类型，可以进行四则运算还有取余等操作。但是对于指针而言，大部分的int新操作对其都是无意义的。此时我们从行为上来对类型进行了区分。
  现在我们知道了，同样内存大小的东西可能不是同一个类。具有相同行为的东西也可能不是同一个类。

- C++中的类
  类是一种将抽象转换为C++的**工具**，它将数据表示和数据操纵的方法组合称为一个整洁的包

- 接口：
  接口是一种设计理念，有点像交易中的契约书。买方只管货对不对就行了，而不用管卖方是如何做出这个东西来的；而卖方只管把东西做出来，不过买方是如何使用的。

- OOP与C++
  OOP是一种编程风格，它将一系列相关的数据类型与函数组合成一个整体，数据内容只对相应的函数开放，对外部保留。用户只关心输入和输出值，并不关心函数是在何时被运行的以及如何实现的。

  既然存在这种区别对待的要求，C++是如何实现的呢？关键字private、public和protected。分别表示私有、公开和保护类型。但是就具体的C++实现而言，目的就是隐藏数据，所以如果没有特殊关键字声明，所有的类成员都是默认为private。
  

##  如何定义和实现类
类的四要素：关键字——class、类名——ClassName、权限——private，public，protected、类成员——classMember

##  公有访问、私有访问、保护访问
以人为例，你知道张三，同时也知道张三的模样与张三习惯性的动作。但是你不能张三做出任何更改除了张三自己。类同样如此，使用类来实例化了一个对象，你可以访问该对象的public所公开的部分。但是无法更改任何private的数据除了通过public所公开的方式。可以说public与private是对外部使用者而言的，但是类存在继承的问题，此时父类与子类之间的权限又产生了一种新的关系，这就产生了关键字protected。

##  创建和使用类对象
其实类的概念我觉得有点像C语言中源文件与头文件的作用，我在头文件中定义能够被第三方所使用的类型和方法，我在源文件中去实现头文件中类型和方法。但是有时源文件中可不仅仅只用头文件提供的哪些类型和方法，有些只提供给源文件内部使用的类型和方法。类在这个大的理念上做出了发展，参考头文件与源文件的关系，可以衍生出类声明与类实现。但是在此基础上，类通过在类声明中使用一些技术手段划分了类声明的开放权限。其次是我们一般在头文件和源文件中都是直接对声明中的函数实现定义即可。但是C++类不同，C++的类具有namespace的属性，自身就代表了一个独立的空间，所以你在源文件中实现类中函数的定义时还需要考虑空间的兼容性问题。一般是使用作用域解析符号来限定函数实现的空间位置。

类的访问与结构体一样，是通过对象主动调用的。

##  类的数据成员
此处需要说明的一点是，注意区分类成员与权限。成员是成员、权限是权限；只是类产生的宗旨是为了隐藏数据，所以无论什么类型的数据都建议设置为private权限，其中可以被外界访问的数据新定义一种public方式来公开修改的方法。

##  类方法(类函数对象)
- 成员函数的使用
  类成员函数的行为与源文件中的函数很类似，具体表现为不管你怎样调用，我的函数实现都只有一个。其实就是不管你是同一个类型的不同对象，你调用类中同名的方法时，使用的都是同一份源代码文件，但是具体执行的堆栈的位置可能不同。

- 内联方法
  1、定义在类声明中的方法都会自动被转换为类的内联方法。2、对于源文件中使用inline实现的方法也都将被定义为类的内联函数。内联函数的作用域相当于与类声明进行了绑定，又有在引用了类声明的文件作用域内才能使用。

##  类的构造函数和析构函数
- 是什么？
  值得好奇的是，为什么使用声明后就得到了类的对象。在C/C++中使用结构时也需要初始化才能进行下一步操作，为什么类没有呢？
  其实不是类没有，而是类将它的初始化方式给隐藏起来了，在你使用声明定义一个新对象的同时，就发生了类的初始化，这些都是由编译器幕后进行的，所以使用方是没有任何感觉的。其实这也是合理的，因为类的设计之初就是用来包含和隐藏数据的，一般都是在初始化之后将保持数据不被更改。

  你可能会疑惑，自己定义的类中并没有定义类的构造函数和析构函数，但是我的类还是能够工作呀？这是因为编译器在检测到你使用类定义时，就会去找类的构造函数，在发现没有找到后将会生成一个默认构造函数，你其实使用的就是这个默认构造函数。这儿就会有一个万恶之源(默认构造函数)，你要知道猜测别人的意图是一件很难的事，同类之间尚且是如此，更何况是编译期呢？

  大多数情况下，程序员都是不相信编译的默认构造函数的，而是自己重新定义一个新的构造函数。

- 为什么？
  为什么需要构造函数和析构函数呢？
  - 管理内存
    C++有严格的内存管理机制，如果你是使用的随机分配内存，则分配内存的任务由编译器承担。但是如果是动态内存，则你的构造函数负责申请内存，析构函数负责释放内存。
  - 初始化
    由于类的设计属性，使得初始化是必不可少的，在申请内存空间后第一步就是实现初始化

- 怎样实现？
  C++语法如下：
  ```c++{.line-numbers}
  //  constructor function
  ClassName(paraments);
  //  destructor function
  ~ClassName();
  ```

  - 说明
    从函数的角度去理解构造函数，该函数只是执行内存申请与对象成员的初始化。所以C++将其规定为与类同名的函数名，同时其参数为各种初始化情况所需要的参数，最重要的一点是，它没有返回值。想象一下，你在声明情况下会使用到构造函数，只用声明一个类对象时才需要，此时就会调用类构造函数，如果存在返回值会发生什么情况，声明变量就可以被表达式所使用。但是这种情况是不符合逻辑的，声明对象你要的并不是那一个结果，而是你定义的对象本身。你现在已经有一个可以直接操作对象的对象名存在了，任何其他的返回都是没有意义的。
    对于析构函数而言，C++将其定义为~+类名的形式，~用于区分构造函数。对于析构函数而言，它是不需要参数的，因为它所管理的是类成员，而所有的类成员对析构函数都是开放的，所以无需外部参数。

##  const成员函数
说道const成员函数，必须先说明const类。**C++的宗旨是像类型一样使用类**，对于一般的类型来说，已经可以满足要求了，但是还存在一种特殊的关键字const，const加类型名的组合同样也应该适用于类。

- const ClassName Object
  要实现这样使用类，很明显，普通的类定义是到不到要求的。此时就诞生了const类数据成员与const类函数成员。
  - const类数据成员
    类相当于一份独立空间的源文件，所以const类数据成员就像在源文件中使用const限定符就好了。
    const TypeName xxx；
  - const类函数成员
    - 为什么需要const类函数成员
      因为对于外接而言，我本来就不能够访问你的数据，都是通过类的public接口来访问数据的。为了保证类提供的接口不会修改类中的数据项成员————所以C++新增了const类函数的概念
    - 怎样来实现const类函数成员呢？
      既然类型可以通过const加上类型名，那么函数可以吗？这样尝试过后发现，这和现有的概念冲突了，因为如果是在函数名称前加上const将会被编译器认定为返回类型为const，这与我们想要表达的含义相违背。同时也和现有的C/C++基础相违背。既然前面不行，我在函数名称后面使用const行吗？没错，C++采用的就是这种方式。
    通过const的限制的函数表明，该类成员函数不会尝试修改类中的数据类型(任何尝试对数据项进行更改的动作，编译器都会捕获然后报错)。


##  this指针
- 什么是this指针？
  this指针C++类中隐藏的一个默认类指针，它指向类的实例化对象本身。

- 为什么需要this指针？
  1、有些特殊函数需要返回对象本身，这样就可以向cin一样连续调用了。
  2、有时还有可能存在其他的对象最为参数传递到函数中，它们的成员名称可能一样，为了区分，同样可以使用this指针。

- 怎样使用this指针？
  this指针与类指针/结构体指针类似，都是通过->来访问成员的，如果用的不习惯，可以使用(*this).来访问成员。


###  深入理解this指针
有时候很好奇，this指针是怎样实现的呢？代码如下：
```c++{.line-numbers}
void Stock::Show(void) const
{
  cout << "Company: " << company;
}
```
C风格如下：
```c{.line-numbers}
void Show(const Stock* this)
{
  cout << "Company: " << company;
}
```
可以看出，其实实现方式也很简单，就是增加一个参数，其实类中也是类似的操作。其实我们看到的类与编译器实现的类还是有很大的不同，编译器实现的类中还用有相应的**隐藏空间**，在这个隐藏空间内其实就存在名为this的成员变量。该变量在类申请空间时实现初始化，在调用析构函数是被隐藏释放。这也就是为什么即便析构函数什么都不做，还是要存在的原因。其实你所定义的析构函数只是用于管理你定义的类成员，而编译器提供的析构函数用于管理编译器一层的内存管理。(其实不止是this指针，后续的继承中虚函数也会使用到隐藏空间)



##  创建对象数组与初始化
在很多情况下，我们需要的是一系列对象的集合，是一个对象数组。其声明方式也很简单，和使用基本类型数组一样，同样是ClassName xxx[SIZE]。
- 初始化
  ```C++{.line-numbers}
  class Test
  {

  }
  //  1.default init
  Test t_array[10];
  //  2.assignment init
  Test t_array[10] = {
    Test(1),
    Test(2),
    ...
  }
  //  3.variable init
  Test t_array[10] = {
    Test(1,2),
    Test(1),
    ...
  }
  ```
  1，第一种情况下，程序将会依次调用数组对象的初始化函数来实现初始化。
  2，第二种情况下，相当于通过代码指明告诉程序去主动调用类的初始化函数。
  3，第三种情况下，如果类存在多种构造函数，那么可以通过主动调用多种构造函数来实现不同构造函数的初始化。

- 初始化原理
  首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象中的内容复制到相应的元素中去。

  分析：
  ~~这就说明了，其实严格来说使用花括号初始化实际上是一个赋值的过程，对象数组在声明时就已经完成了内存空间的分配了。也就表明，const类型的对象是不适合这种初始化方式的(构造函数的初始化列表)。再有一点值得注意的是，**主动调用构造函数是会生成一个临时的对象**，该对象没有名称，所以仅仅在这一个逗号表达式中存在，复制完成后将会调用析构函数来释放内存空间。最后一点需要注意，它们之间发生的是复制过程，那一有没有想过对象之间是怎样复制的呢？其实对象的复制是重定义了=操作符(t_array[2].=operator(Test(1,2,3));其实本质上就是一个函数的嵌套。你可能会有疑问，我没有重定义操作符呀，为什么复制的结果是我想要的，其实编译器同样会提供赋值构造函数和复制操作符的重定义。~~
  我理解错了，没错数组对象的确在声明是就已经调用了默认构造函数，所以如果不存在默认构造函数时，编译器将会报错。而使用花括号中主动调用构造函数将会生成此逗号表达式作用域的临时变量，然后数组对象将会调用复制操作符的重载，因为现在是两个存在的实体，所以调用的是赋值操作符。(t_array[1].=operator(Test(1,2,3)));在上面的分析中我差点将什么时候调用复制构造函数和什么时候使用赋值运算符弄混。(注意：如果操作符两边都是已经存在的实体，将会使用赋值运算符=；如果主动调用的一方是实体，而另一方还不存在，将会调用复制构造函数来进行它们之间的运算。)

  补充：
  c++编译器将为类默认提供下面的基础函数
  - 默认构造函数，如果没有显示定义
  - 默认析构函数，如果没有定义
  - 复制构造函数，如果没有定义
  - 赋值运算符，如果没有定义
  - 地址运算符，如果没有定义


##  类作用域
类是用来管理数据和行为，所以很多时候都会对类中的数据存在限制要求，这种限制只是对使用该类声明生成对象的限制，但是却不是对整体的程序的行为进行限制。这种限制我们最好是都将其定义在类空间中，这样方便管理和更改，且在不使用类时，还不会占用内存空间。有人可能想到了使用const来实现，代码如下：
```c++{.line-numbers}
class Name
{
private:
  const int LIMIT = 20;
  char fname[LIMIT];
}
```
这样其实是不能正常工作的，因为你只是在类声明中定义了，你定义了计算机一定执行吗？不一定，程序只有当计算机的pc指到的位置才会运行，这样做存在两个问题：
- 问题1：编译器不知道该类所需要申请的内存空间是多大而报错
  其实我们所使用的所有类型，编译器其实在编译阶段通过内置函数——类似于sizeof()计算出了该类型所需要申请的空间有多大，然后再向操作系统申请该内存大小的存储空间，然后操作系统根据是否存在const关键字来进行一次该内存地址的初始化。然后将它交给程序使用，此时程序在进行初始化(如果程序存在的话)。因为编译器不会执行类空间中的代码，所以无法获取该类型的所需空间的大小，从而报错。

- 问题2：const类成员的初始化问题
  ~~上面已经提到了，操作系统提供内存空间时就会检查是否存在关键字const，从而进行初始化。~~
  我将const变量和类常量的概念混淆了，导致以为这样写是不合法的。

- C++提供的解决之道
  - 类枚举
    ```c++{.line-numbers}
    class EnumTest
    {
      private:
        enum {Months = 12};
        double costs[Months];
    }
    ```
  - static常量关键字
    ```c++{.line-numbers}
    class Test
    {
      private:
        static const int Months = 12;
        double costs[Months];
    }
    ```
  本质上它们并没有与编译器的中相冲突，
  枚举是利用的c/c++的预处理器的工作原理来实现的，因为预处理器将会进行替换操作，经过预处理器后，你最终的代码实际上是double costs[12]。
  static申请的内存空间不同于自动和heap，是另外一种内存管理的技术。你可以这样理解，编译器在编译代码后将会统计所有的static和全局变量的大小，程序在执行时，将会将它们告知给操作系统，操作系统将会分配足够的内存空间。(以上纯属本人瞎猜，我也还没搞懂，暂时这样理解吧。)

##  抽象数据类型