[toc]

#  using class

##  运算符重载
- 问题的引出？
  有没有想过int、float等类型为什么能够进行+、-、*、÷等运算。类能实现同样的操作吗？类应该怎样实现呢？

- 我的理解
  其实int、float等和类其实没有什么区别，或者严格来说它们就是类。它们之所以能够使用这些运算符并没有什么特殊性，只是因为他们public了一种特殊的函数接口 ———— 运算符函数。


- 课本
  - 运算符重载与OOP目的
    **运算符重载是一种形式的C++多态**，C++根据操作数的数目和类型来决定采用那种操作方式。运算符重载实现的OOP目标————隐藏内部机理，强调实质。
  - C++运算符重载函数的通式
    ```c++{.line-numbers}
    operatorOP(argument-list)
    // example
    operator+(int i, int j);
    operator*(int i, int j);
    ```
  - 重载限制
    1、所有的运算符重载中，该运算符必须是C++已经拥有的运算符。
    2、重载的运算符不必是成员函数，但是必须至少有一个操作数是用户定义的类型。因为基本类型的运算符重载已经由编译器提供了。其次是避免混乱，如果可以重载基本运算符后所有的基础都会被推翻，如使用-来实现+号的功能。
    3、使用运算符时不能违反运算符原来的句法规则。你不能将一个原来需要两个操作数的运算符重载为只需要一个操作数。
    4、重载不能更改现有运算符的优先级。
    5、不能创建新运算符
    6、不能重载线面的运算符
      - sizeof：sizeof运算符
      - .：成员运算符
      - .*：成员指针运算符
      - ::：作用域解析符
      - ?:：条件运算符
      - typeid：一个RTTI运算符
      - const_cast：强制类型转换运算符
      - dynamic_cast：强制类型转换运算符
      - reinterpret_cast：强制类型转换运算符
      - static_cast：强制类型转换运算符
    7、一般的运算符都能进行成员或非成员重载，但是下面的运算符只能通过成员实现重载
      - =：赋值运算符
      - ()：函数调用运算符
      - []：下标运算符
      - ->：通过指针访问类成员的运算符

- 问题
  - 为什么说运算符重载是C++多态？
    我对运算符重载的概念理解错了，我将重载理解为了类的行为，将其理解为了类开放的一个接口。但是这样理解是不准确的。1、没有考虑到同一个符号能个用于多种不同的类型中————C++重载的目的。2、没有考虑到友元函数，有些类的运算符实现就是依靠友元函数来实现的，但是严格来说友元函数并不属于类的行为。
  - 再类中实现运算符重载的意义？
    其实类中的运算符重载与类外的运算符重载没有区别，在类中实现的原因是，类成员函数有权限访问类中的是由变量，以便能够更好，更便利的实现类所需要的重载。
  - 为什么第7点中的运算符只能用于类成员呢？
    ~~可以看到上述运算符左边必须存在一个操作数，严格来说这些操作符都是由左边的操作数所发起的行为~~
  
##  友元函数
- 问题的引出？
  有些特定的外部函数可能需要使用到特定类对象中的特定数据，但是由于类中的数据都是被private隐藏的，所以只能通过该类开放的函数还能获取相应的数据，但有时可能还没有开放相应数据的函数。

- 我的理解
  特别是那种需要解决多个类之间相关的运算，你没办法将该操作定义为一个单独的类行为，所以需要友元函数来实现。

- 课本
  C++控制对类对象私有部分的访问。通常，公有类方法提供唯一的访问途径，但是有时候这种限制太过严格，以至于不至于特定的编程问题。未解决这种问题————C++提供了另一种形式的访问权限：友元

  - 3种友元
    1、友元函数 ———— 在类的外部函数能够访问类中的私有数据
    2、友元类 ———— 一个友元类能够拥有另一个类的私有数据的访问权限
    3、友元成员函数 ———— 类的成员函数能够其他类数据的访问权限
  通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。也就是说————友元函数拥有与类成员函数同样的访问类私有数据的权限。

  - 为什么需要友元
    如实现类与int类型的乘法。你可能会在类中重载*运算符。但是会造成这样一个问题
    ```c++{.line-numbers}
    class People
    {
      public:
        operator*(int a);
    }

    People a;
    result = a * 10;    //  valid
    result = 10 * a;    //  invalid
    ```
    1、因为乘法是可交换的，但是类成员运算符的操作数的位置都是已经固定了(必须是由该类发起调用)，同时我们又不可能对基本类型再添加一个运算符重载(不符合C++的语法)。所以就有了友元的产生。
    2、其次，从概念上来说，a * 10与10 * a本质上是同一个东西，它们严格来说不属于类的行为了，它们是一个公众行为。(有点像姓名虽然是你私有的，但是不妨碍别人知道你的名字)
    - 解决方法
      友元非成员函数(记住，大多数运算符都可以通过成员或非成员函数来重载)。非成员函数不是有对象发起调用的，它使用的所有值包括对象都是显示参数。
    ```c++{.line-numbers}
    class People
    {
      public:
        friend operator*(double m, People& p);
    }
    operator*(double m, People& p);

    result = 10 * a;  ==> operator*(double(10), a);
    ```

  - 创建友元
    1、将原型放在类声明中，并在原型声明前加上关键字**friend**
    2、实现友元函数定义。因为它不是类成员函数，所以不需要使用类作用域解析符还强调函数的范围。
    - 说明：
      1、虽然operator*()函数在类中被声明，但是他不是类的成员函数，所以不能使用类来调用该方法
      2、虽然operator*()函数不是成员还是，但是通拥有与类成员函数同样的访问权限

  - 讨论————友元是否有悖于OOP
    乍一看可能认为友元违反了OOP————即类隐藏数据的原则，因为在非成员函数中访问了成员函数。其实应该将友元函数视为**类扩展接口的组成部分**，因为从概念上来看double * Time与Time * double完全相同。造成它们之间差异的是因为C++语法的限制结果。此外，友元函数只有在相应的类中声明后才能使用类中的数据，也就是说类同时控制了友元函数的有无。

    如果实在难以理解可以使用运算符的重定义来实现和友元函数同样的行为，代码如下：
    ```c++{.line-numbers}
    Time operator*(double m, const Time& t)
    {
      return t*m;   //  t.operator*(m)
    }
    ```
    

##  重载<<运算符，以便用于输出
##  状态成员
##  使用rand()生成随机值
##  类的自动转换和强制类型转换
##  类转换函数

