[toc]

#  对象和类
##  内容：
##  过程性编程和面向对象编程
- 我的理解：
  - 过程性编程
    使用语言提供的基础数据类型、按特定的算法步骤编写程序逻辑、一般对于不同的流程使用不同的函数来达到数据处理的过程。
  - 面向对象编程
    关注于数据本身的表现与行为、创造了新的数据类型。

- 书本：
  - 过程性编程
    遵循特定的步骤处理数据 ———— 整体步骤优先与数据
  - 面向对象编程
    首先考虑数据，然后考虑如何使用这些数据。

- 区别：
  过程性编程和明显，是以过程为导向的思维方式，按什么顺序获取数据，数据按什么流程进行处理。也就是说，你没办法按你想要的方式去对数据进行处理，因为对数据进行处理的流程是固定的。就存在这样一种情况，有些数据，我可能只是需要数据的一部分，可是按流程处理后得到的是全方面处理后的数据。这种方式很适合统一流程处理数据。优点：统一、标准；缺点：不灵活、死板。
  面向对象编程考虑的是数据的抽象以及行为方式。是一种以数据为导向的编程方式。可以通过数据不同的表现方式来处理同一数据或者是不同数据。优点：灵活。

- OOP编程与类的关系
  OOP是一种编程理念，而类是该理念实现的一种方式。

##  类概念
- 我的理解：
  就一个事物而言，是存在多种属性的，我们关注的是其中的某一项属性。此时就需要简化模型与然后提取抽象，然后将抽象的部分视为一个研究的整体，这样就构成了类的概念。所以抽象与类是相辅相成的。类是某部分抽象的集合。

- 类型是什么？
  比如如何区分char与double类型，我们可以从其表示的存储空间的大小出发。这样就有一个问题，内存空间大小一样的一定是同一个概念吗？如在C和C++中，指针类型和int类型的存储空间相同。有时甚至用int型来存储指针。但是它们就是同一个概念了吗？不是，那么我们是怎样来区分它们的呢？对于int类型，可以进行四则运算还有取余等操作。但是对于指针而言，大部分的int新操作对其都是无意义的。此时我们从行为上来对类型进行了区分。
  现在我们知道了，同样内存大小的东西可能不是同一个类。具有相同行为的东西也可能不是同一个类。

- C++中的类
  类是一种将抽象转换为C++的**工具**，它将数据表示和数据操纵的方法组合称为一个整洁的包

- 接口：
  接口是一种设计理念，有点像交易中的契约书。买方只管货对不对就行了，而不用管卖方是如何做出这个东西来的；而卖方只管把东西做出来，不过买方是如何使用的。

- OOP与C++
  OOP是一种编程风格，它将一系列相关的数据类型与函数组合成一个整体，数据内容只对相应的函数开放，对外部保留。用户只关心输入和输出值，并不关心函数是在何时被运行的以及如何实现的。

  既然存在这种区别对待的要求，C++是如何实现的呢？关键字private、public和protected。分别表示私有、公开和保护类型。但是就具体的C++实现而言，目的就是隐藏数据，所以如果没有特殊关键字声明，所有的类成员都是默认为private。
  

##  如何定义和实现类
类的四要素：关键字——class、类名——ClassName、权限——private，public，protected、类成员——classMember

##  公有访问、私有访问、保护访问
以人为例，你知道张三，同时也知道张三的模样与张三习惯性的动作。但是你不能张三做出任何更改除了张三自己。类同样如此，使用类来实例化了一个对象，你可以访问该对象的public所公开的部分。但是无法更改任何private的数据除了通过public所公开的方式。可以说public与private是对外部使用者而言的，但是类存在继承的问题，此时父类与子类之间的权限又产生了一种新的关系，这就产生了关键字protected。

##  创建和使用类对象
其实类的概念我觉得有点像C语言中源文件与头文件的作用，我在头文件中定义能够被第三方所使用的类型和方法，我在源文件中去实现头文件中类型和方法。但是有时源文件中可不仅仅只用头文件提供的哪些类型和方法，有些只提供给源文件内部使用的类型和方法。类在这个大的理念上做出了发展，参考头文件与源文件的关系，可以衍生出类声明与类实现。但是在此基础上，类通过在类声明中使用一些技术手段划分了类声明的开放权限。其次是我们一般在头文件和源文件中都是直接对声明中的函数实现定义即可。但是C++类不同，C++的类具有namespace的属性，自身就代表了一个独立的空间，所以你在源文件中实现类中函数的定义时还需要考虑空间的兼容性问题。一般是使用作用域解析符号来限定函数实现的空间位置。

类的访问与结构体一样，是通过对象主动调用的。

##  类的数据成员
此处需要说明的一点是，注意区分类成员与权限。成员是成员、权限是权限；只是类产生的宗旨是为了隐藏数据，所以无论什么类型的数据都建议设置为private权限，其中可以被外界访问的数据新定义一种public方式来公开修改的方法。

##  类方法(类函数对象)
- 成员函数的使用
  类成员函数的行为与源文件中的函数很类似，具体表现为不管你怎样调用，我的函数实现都只有一个。其实就是不管你是同一个类型的不同对象，你调用类中同名的方法时，使用的都是同一份源代码文件，但是具体执行的堆栈的位置可能不同。

- 内联方法
  1、定义在类声明中的方法都会自动被转换为类的内联方法。2、对于源文件中使用inline实现的方法也都将被定义为类的内联函数。内联函数的作用域相当于与类声明进行了绑定，又有在引用了类声明的文件作用域内才能使用。

##  类的构造函数和析构函数
值得好奇的是，为什么使用声明后就得到了类的对象。在C/C++中使用结构时也需要初始化才能进行下一步操作，为什么类没有呢？
其实不是类没有，而是类将它的初始化方式给隐藏起来了，在你使用声明定义一个新对象的同时，就发生了类的初始化，这些都是由编译器幕后进行的，所以使用方是没有任何感觉的。其实这也是合理的，因为类的设计之初就是用来包含和隐藏数据的，一般都是在初始化之后将保持数据不被更改。

你可能会疑惑，自己定义的类中并没有定义类的构造函数和析构函数，但是我的类还是能够工作呀？这是因为编译器在检测到你使用类定义时，就会去找类的构造函数，在发现没有找到后将会生成一个默认构造函数，你其实使用的就是这个默认构造函数。这儿就会有一个万恶之源(默认构造函数)，你要知道猜测别人的意图是一件很难的事，同类之间尚且是如此，更何况是编译期呢？

大多数情况下，程序员都是不相信编译的默认构造函数的，而是自己重新定义一个新的构造函数。

##  const成员函数
##  this指针
##  创建对象数组
##  类作用域
##  抽象数据类型