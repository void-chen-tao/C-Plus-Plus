[toc]

#  using class

##  运算符重载
- 问题的引出？
  有没有想过int、float等类型为什么能够进行+、-、*、÷等运算。类能实现同样的操作吗？类应该怎样实现呢？

- 我的理解
  其实int、float等和类其实没有什么区别，或者严格来说它们就是类。它们之所以能够使用这些运算符并没有什么特殊性，只是因为他们public了一种特殊的函数接口 ———— 运算符函数。


- 课本
  - 运算符重载与OOP目的
    **运算符重载是一种形式的C++多态**，C++根据操作数的数目和类型来决定采用那种操作方式。运算符重载实现的OOP目标————隐藏内部机理，强调实质。
  - C++运算符重载函数的通式
    ```c++{.line-numbers}
    operatorOP(argument-list)
    // example
    operator+(int i, int j);
    operator*(int i, int j);
    ```
  - 重载限制
    1、所有的运算符重载中，该运算符必须是C++已经拥有的运算符。
    2、重载的运算符不必是成员函数，但是必须至少有一个操作数是用户定义的类型。因为基本类型的运算符重载已经由编译器提供了。其次是避免混乱，如果可以重载基本运算符后所有的基础都会被推翻，如使用-来实现+号的功能。
    3、使用运算符时不能违反运算符原来的句法规则。你不能将一个原来需要两个操作数的运算符重载为只需要一个操作数。
    4、重载不能更改现有运算符的优先级。
    5、不能创建新运算符
    6、不能重载线面的运算符
      - sizeof：sizeof运算符
      - .：成员运算符
      - .*：成员指针运算符
      - ::：作用域解析符
      - ?:：条件运算符
      - typeid：一个RTTI运算符
      - const_cast：强制类型转换运算符
      - dynamic_cast：强制类型转换运算符
      - reinterpret_cast：强制类型转换运算符
      - static_cast：强制类型转换运算符
    7、一般的运算符都能进行成员或非成员重载，但是下面的运算符只能通过成员实现重载
      - =：赋值运算符
      - ()：函数调用运算符
      - []：下标运算符
      - ->：通过指针访问类成员的运算符

- 问题
  - 为什么说运算符重载是C++多态？
    我对运算符重载的概念理解错了，我将重载理解为了类的行为，将其理解为了类开放的一个接口。但是这样理解是不准确的。1、没有考虑到同一个符号能个用于多种不同的类型中————C++重载的目的。2、没有考虑到友元函数，有些类的运算符实现就是依靠友元函数来实现的，但是严格来说友元函数并不属于类的行为。
  - 再类中实现运算符重载的意义？
    其实类中的运算符重载与类外的运算符重载没有区别，在类中实现的原因是，类成员函数有权限访问类中的是由变量，以便能够更好，更便利的实现类所需要的重载。
  - 为什么第7点中的运算符只能用于类成员呢？
    ~~可以看到上述运算符左边必须存在一个操作数，严格来说这些操作符都是由左边的操作数所发起的行为~~
  
##  友元函数
- 问题的引出？
  有些特定的外部函数可能需要使用到特定类对象中的特定数据，但是由于类中的数据都是被private隐藏的，所以只能通过该类开放的函数还能获取相应的数据，但有时可能还没有开放相应数据的函数。

- 我的理解
  特别是那种需要解决多个类之间相关的运算，你没办法将该操作定义为一个单独的类行为，所以需要友元函数来实现。

- 课本
  C++控制对类对象私有部分的访问。通常，公有类方法提供唯一的访问途径，但是有时候这种限制太过严格，以至于不至于特定的编程问题。未解决这种问题————C++提供了另一种形式的访问权限：友元

  - 3种友元
    1、友元函数 ———— 在类的外部函数能够访问类中的私有数据
    2、友元类 ———— 一个友元类能够拥有另一个类的私有数据的访问权限
    3、友元成员函数 ———— 类的成员函数能够其他类数据的访问权限
  通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。也就是说————友元函数拥有与类成员函数同样的访问类私有数据的权限。

  - 为什么需要友元
    如实现类与int类型的乘法。你可能会在类中重载*运算符。但是会造成这样一个问题
    ```c++{.line-numbers}
    class People
    {
      public:
        operator*(int a);
    }

    People a;
    result = a * 10;    //  valid
    result = 10 * a;    //  invalid
    ```
    1、因为乘法是可交换的，但是类成员运算符的操作数的位置都是已经固定了(必须是由该类发起调用)，同时我们又不可能对基本类型再添加一个运算符重载(不符合C++的语法)。所以就有了友元的产生。
    2、其次，从概念上来说，a * 10与10 * a本质上是同一个东西，它们严格来说不属于类的行为了，它们是一个公众行为。(有点像姓名虽然是你私有的，但是不妨碍别人知道你的名字)
    - 解决方法
      友元非成员函数(记住，大多数运算符都可以通过成员或非成员函数来重载)。非成员函数不是有对象发起调用的，它使用的所有值包括对象都是显示参数。
    ```c++{.line-numbers}
    class People
    {
      public:
        friend operator*(double m, People& p);
    }
    operator*(double m, People& p);

    result = 10 * a;  ==> operator*(double(10), a);
    ```

  - 创建友元
    1、将原型放在类声明中，并在原型声明前加上关键字**friend**
    2、实现友元函数定义。因为它不是类成员函数，所以不需要使用类作用域解析符还强调函数的范围。
    - 说明：
      1、虽然operator*()函数在类中被声明，但是他不是类的成员函数，所以不能使用类来调用该方法
      2、虽然operator*()函数不是成员还是，但是通拥有与类成员函数同样的访问权限

  - 讨论————友元是否有悖于OOP
    乍一看可能认为友元违反了OOP————即类隐藏数据的原则，因为在非成员函数中访问了成员函数。其实应该将友元函数视为**类扩展接口的组成部分**，因为从概念上来看double * Time与Time * double完全相同。造成它们之间差异的是因为C++语法的限制结果。此外，友元函数只有在相应的类中声明后才能使用类中的数据，也就是说类同时控制了友元函数的有无。

    如果实在难以理解可以使用运算符的重定义来实现和友元函数同样的行为，代码如下：
    ```c++{.line-numbers}
    Time operator*(double m, const Time& t)
    {
      return t*m;   //  t.operator*(m)
    }
    ```


##  重载<<运算符，以便用于输出
这是一种C++同一管理输出的思想，因为cout属于ostream类，并且在该类中标准已经实现了对所有类型的operator<<的重定义，所以cout<<输出实际上是调用类中相应的方法类来实现的。我们现在想让ostream类也能实现识别我们自定义类的输出。一种方式是在ostream类中增加我们自定义的类输出的重载，但是一旦对标准改动就意味着失去了移植性。仔细分析我们可以知道，我们并不会使用到cout中的私有数据，只需要使用cout使用我们自定义类中的私有数据即可。
1、第一种方式重载<<
```c++{.line-numbers}
void operator<<(ostream& os, const Time& t)
{
  os << t.hours << " hours, " << t.minutes << " minutes";
}
```
2、第二种方式重载<<
前面这种重载只考虑到了该类的输出，没有考虑到多重输出的情况————cout << "hello" << ", world"; 改进版如下：
```c++{.line-numbers}
ostream& operator<<(ostream& os, const Time& t)
{
  os << t.hours << " hours, " << t.minutes << " minutes";
  return os;
}
```

- 讨论：什么时候使用友元，什么时候不使用友元，必须是谁的友元
  不要陷入在类外部重载了运算符将其它的类作为参数传入时，该运算符重载函数必须是其他类的友元。以上式为例，我们根本没有访问ostream类的内部元素，只是使用ostream类的public接口来实现Time私有数据的输出。所以，该运算符重载必须是Time类的友元，而不必是ostream类的友元。所以我们无需对ostream类做出任何修改。这也就意味着代码是可移植的。

- 补充：
  *非成员版本的重载运算符函数所需的形参数目与运算符使用的操作数数目相同；而成员版本所需的参数数据少一个，因为其中一个操作数被隐式地传递给调用对象*

##  状态成员
##  使用rand()生成随机值
##  类的自动转换和强制类型转换
- 复习C++如何处理数据转换
  1、将一个标准类型变量的值赋值给另一种标准类型的变量时，如果这两种类型兼容，C++将自动将这个值转换为接收变量的类型。————如long、int、double等都是兼容的类型。
  2、C++语言**不自动转换不兼容的类型**。————此时如果使用者非要这样做，必须使用强制类型转换

- 用户自定义类如何实现强制类型转换
  在C++中，**接受一个参数的构造函数将类型与该参数相同的值转换为类提供了蓝图**。
- 代码演示
  ```c++{.line-numbers}
  class Test
  {
    public:
      Test(double);
  }
  Test a;
  a = 20.999;
  ```
  上述代码是合法的，但是注意一点，你也可以将上述代码理解为使用了从double类型强制转换为了Test类型。
- 原理说明：
  1、程序将会使用Test类的构造函数Test(double)来创建一个临时的Test对象，然后a对象将会调用operator=操作符来实现*逐个成员赋值的方式将该临时对象的内容复制到a对象中*(operator=类成员函数如果没有显式指明，编译器将会提供默认赋值运算符函数)。
  2、只有接受一个参数的构造函数才能作为转换函数。所以如果构造函数存在多个参数，将不能作为类型转换函数来使用。但是如果对于多参数的构造函数，如果只有一个参数没有默认值，其他参数存在默认值，该构造函数同样也能作为类型转换函数。

- 问题与冲突
  这种类型转换是隐藏式的转换，但是在有些情况下，你可能并不希望你的类进行了隐藏式的强制类型转换。
  - 解决
    C++提供了关键字*explicit*来用于显示关闭这种特性。
  - 演示代码如下：
    ```c++{.line-numbers}
    class Test
    {
      public:
        explicit Test(double a);      //  no implicit conversions allowed
    }
    ```
    注意一点，上述关键字只是禁止了隐式类型转换，但是并没有禁止这种转换方式，所以还是可以使用强制类型转换类实现。

- 总结：
  在不适用explicit关键字的情况下，下面的情况都适用隐式类型转换
  1、将使用double值来初始化Test对象时
  2、将double值赋给Test对象时
  3、将double值传递给接受Test对象为参数的函数时
  4、返回值被声明为Test，但是实际返回double类型时

##  类转换函数
类的构造函数只是提供了某种类型转换到类类型的转换方式，但是多数情况下，转换应该是相互的。但是要实现类类型转换为特定类型必须使用C++提供的另一种解决方案————转换函数
转换函数是用户定义的强制类型转换，可以像强制类型转换那样使用它。

- 转换函数语法
  如果需要转换为typeName类型，必须这样定义转换函数
  operator typeName();

  - 注意点
    1、转换函数必须是类方法
    2、转换函数不能指定返回类型
    3、转换函数不能有参数
  - 解释
    1、因为当前情况下，你需要将类转换为特定的类型，所以必须使用到类中的私有数据格式，所以你就只能使用类成员函数和友元函数。但是友元函数可能会出问题(很严重的二义性问题)
    2、转换函数不能指定返回类型，因为你需要的类型已经由该类型名称提供了
    3、转换函数不能有参数，因为强制类型转换的语法为double(className)或者位(double)className,要求了只有一个操作符，同时又由于是类成员函数，类已经被隐藏传递了，所以不需要接受参数。
